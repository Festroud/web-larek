# Проектная работа "Веб-ларек"
Это учебный проект, созданный в рамках курса Яндекс Практикум. Он предлагает пользователям возможность взаимодействовать с системой для заказа товаров, предназначенных для веб-разработчиков.

## Стек технологий
- **HTML**
- **SCSS**
- **TypeScript**
- **Webpack**

## Структура проекта
- `src/` — исходные файлы проекта
- `src/components/` — папка с JS компонентами
- `src/components/base/` — папка с базовым кодом
- `src/pages/index.html` — HTML-файл главной страницы
- `src/types/index.ts` — файл с типами
- `src/index.ts` — точка входа приложения
- `src/scss/styles.scss` — корневой файл стилей
- `src/utils/constants.ts` — файл с константами
- `src/utils/utils.ts` — файл с утилитами

## Инструкция по сборке и запуску
1. Установить зависимости:
   ```bash
   npm install
   ```
2. Запустить проект в режиме разработки:
   ```bash
   npm run start
   ```
3. Для сборки проекта в продакшен:
   ```bash
   npm run build
   ```
---
## Архитектура проекта Web-Larek
### Базовый код
## Класс `Api`
Класс `Api` предназначен для работы с REST API. Он упрощает выполнение HTTP-запросов, таких как `GET`, `POST`, `PUT`, `DELETE`, и предоставляет единое место для управления базовым URL и настройками запросов.
### Конструктор
**`constructor(baseUrl: string, options: RequestInit = {})`**  
Создает экземпляр API-клиента.
- **Параметры:**
  - `baseUrl` (string): Базовый URL для всех запросов.
  - `options` (RequestInit): Настройки запросов, применяемые по умолчанию. Может включать в себя:
   - `headers`: Заголовки (например, авторизация через `Authorization: Bearer <token>`).
---
### Поля
- **`baseUrl` (string):**  
  Хранит базовый URL, указанный при создании экземпляра класса.
- **`options` (RequestInit):**  
  Содержит настройки запросов, включая заголовки (`headers`) и другие параметры, которые применяются по умолчанию ко всем запросам.
---
### Методы
1. `get(uri: string): Promise<object>`  
Выполняет GET-запрос на указанный путь.

- **Параметры:**
  - `uri` (string): Путь к ресурсу (добавляется к `baseUrl`).

- **Возвращает:**  
  Промис с данными, полученными от сервера.
2. `post(uri: string, data: object, method: ApiPostMethods = 'POST'): Promise<object>`
Выполняет POST-запрос (или другой указанный метод) с передачей данных в теле запроса.

- **Параметры:**
`uri (string)`: Путь к ресурсу (добавляется к `baseUrl`).
`data (object)`: Данные, передаваемые в теле запроса (в формате JSON).
`method (ApiPostMethods): HTTP-метод (POST, PUT, DELETE)`. По умолчанию — `POST`.
- **Возвращает:** 
Промис с данными, полученными от сервера.
**Базовый URL:**
Методы автоматически добавляют базовый `URL (baseUrl)` к переданным путям `(uri)`.
**Обработка ответа:**
При успешном запросе возвращает данные в формате JSON.
При ошибке пытается извлечь сообщение об ошибке из ответа или возвращает текст статуса.
**Типы**
`ApiPostMethods`
Тип для указания методов HTTP-запросов:
`type ApiPostMethods = 'POST' | 'PUT' | 'DELETE';`
`ApiListResponse<Type>`
Тип ответа для получения списка элементов:
```type ApiListResponse<Type> = {
  total: number;
  items: Type[];
};
```

## Класс EventEmitter
- реализует паттерн "Emitter" для работы с событиями, позволяя подписываться на события, генерировать их и управлять подписками. Он реализует интерфейс IEvents, который описывает методы для работы с событиями.

**Возможности:**
- Подписка на событие с использованием строки или регулярного выражения.
- Отписка от события.
- Вызов события с передачей данных.
- Подписка на все события с использованием глобального слушателя.
- Сброс всех обработчиков событий.
- Генерация событий с использованием триггера.
**Поля:**
`_events: Map<EventName, Set<Subscriber>>` — карта, где ключи — имена событий или регулярные выражения, а значения — множества подписчиков, которые слушают эти события.
``constructor() {
    this._events = new Map<EventName, Set<Subscriber>>(); 
}``
Конструктор инициализирует пустую карту _events, которая будет хранить все подписки на события.

**Методы:**
1. `on<T extends object>(eventName: EventName, callback: (event: T) => void): void`
Подписывает обработчик `(callback)` на указанное событие ``(eventName)`.
- `eventName:` Имя события или регулярное выражение, которое будет проверяться при вызове события.
- `callback:` Функция, которая будет вызвана при срабатывании события, принимающая объект данных типа T, связанный с событием.

2. `off(eventName: EventName, callback: Subscriber): void`
Удаляет обработчик `(callback)` для указанного события `(eventName)`.
`eventName:` Имя события, с которого нужно снять обработчик.
`callback:` Обработчик, который нужно удалить.

3. `emit<T extends object>(eventName: string, data?: T): void`
Инициирует событие с переданным именем `(eventName)` и данными `(data)`.
`eventName:` Имя события, которое должно быть вызвано.
`data:` Данные, которые могут быть переданы подписчикам при срабатывании события (необязательный параметр).

4. `onAll(callback: (event: EmitterEvent) => void): void`
Подписка на все события. Когда любое событие срабатывает, вызывается указанный обработчик `(callback)`.
`callback:` Функция, которая будет вызвана для каждого события, получая объект с именем события `(eventName)` и данными `(data)`.

5. `offAll(): void`
Удаляет все подписки на события, очищая хранилище `_events`.

6. `trigger<T extends object>(eventName: string, context?: Partial<T>): (data: T) => void`
Создаёт функцию-генератор события, которая при вызове будет инициировать событие с указанными данными.

`eventName:` Имя события, которое нужно инициировать.
`context:` Дополнительные данные, которые будут объединены с переданными при вызове триггера (необязательный параметр).

**Типы:**
``type EventName = string | RegExp;
type Subscriber = Function;
type EmitterEvent = { eventName: string; data: unknown };``

**Основные методы:**
- `on` — подписка на событие. Если событие ещё не зарегистрировано, оно создаётся.
- `off` — удаляет указанный обработчик `(callback)` из списка подписчиков на событие. Если после удаления подписчика для события не остаётся других подписчиков, само событие будет удалено из карты `_events`. Если переданный обработчик `(callback)` не был найден в списке подписчиков для указанного события, метод не вызывает ошибку и не производит изменений.
- `emit` — инициирует событие с указанным именем и переданными данными. Все подписчики события (или подписчики, соответствующие регулярному выражению) будут уведомлены и получат эти данные. Если переданное событие не зарегистрировано, метод `emit` не генерирует ошибку и просто не вызывает никаких обработчиков. В случае события с именем *, метод вызовет все обработчики, подписанные на все события.
- `onAll` — подписка на все события (полезно для отладки или ведения логов).
- `offAll` — удаляет всех подписчиков для всех событий.
- `trigger` — создаёт функцию для генерации события при вызове. Это удобно для создания автоматически инициируемых событий.

**Основные события:**
- `items:changed` — вызывается при изменении списка доступных товаров.
- `item:selected` — возникает при выборе товара пользователем.
- `preview:changed` — вызывается при изменении товара в предварительном просмотре.
- `basket:changed` — генерируется при изменении содержимого корзины.
- `basket:delete` — вызывается при удалении товара из корзины.
- `item:moved` — генерируется при добавлении товара в корзину.
- `modal:open` — вызывается при открытии модального окна.
- `modal:close` — вызывается при закрытии модального окна.
- `order:opened` — генерируется при переходе к оформлению заказа.
- `input:error` — вызывается при ошибках в форме ввода данных.
- `input:change` — вызывается при изменении значения поля ввода.
- `contacts:submit` — вызывается при отправке формы контактных данных.
- `order:submit` — генерируется при отправке формы заказа.
- `order:success` — вызывается при успешной обработке заказа на сервере.

### Описание классов `Model`
1. `ApiModel` (наследуется от класса Api) — отвечает за взаимодействие с сервером. Этот класс передает и получает данные, связанные с заказами и товарами.

*Методы:*
`getListProductCard()` - Получает список товаров с сервера (массив объектов карточек).
`postOrderLot()` - Отправляет данные о заказе на сервер и получает ответ о его статусе.

2. `BasketModel` — управляет данными корзины, которые поступают от пользователя. Хранит информацию о добавленных товарах и их количестве.
```constructor() {
  this.items = []; // Инициализация массива для хранения элементов корзины
  this.totalPrice = 0; // Изначально общая сумма равна 0
}
```
*Методы:*
`getCounter()` - Возвращает количество товаров в корзине.
`getSumAllProducts()` - Рассчитывает и возвращает общую сумму всех товаров в корзине.
`setSelectedCard(product)` - Добавляет товар в корзину.
`deleteCardToBasket(productId)` - Удаляет товар из корзины по идентификатору.
`clearBasketProducts()` - Очищает корзину, удаляя все товары.

3. `DataModel` — хранит и управляет данными товаров, полученными с сервера.
*Метод:*
`setPreview(product)` - Принимает данные выбранного товара и сохраняет их для отображения подробной информации.

4. `FormModel` — отвечает за хранение и валидацию данных, полученных от пользователя (например, адрес доставки и контактные данные).
*Методы:*
`setOrderAddress(address)` - Сохраняет адрес пользователя для оформления заказа.
`validateOrder()` - Проверяет валидность введенного адреса и выбранного способа оплаты.
`setOrderData(contactInfo)` - Принимает и сохраняет контактные данные пользователя (номер телефона, почту).
`validateContacts()` - Проверяет корректность контактных данных.
`getOrderLot()` - Возвращает объект, содержащий данные пользователя и выбранные товары для заказа.

### Описание классов `View`
#### Basket
**Назначение:** Управляет отображением корзины на веб-странице.

**Методы:**
- `renderSumAllProducts(sum: number): void` - Отображает общую сумму всех товаров в корзине. Сумма передается через параметр `sum`, который рассчитывается на основе текущего состояния корзины.

#### Gallery
**Назначение:** Управляет отображением галереи товаров.
**Методы:**
- `setProducts(productElements: HTMLElement[]): void` - Устанавливает элементы товаров в галерее.
- `render(): void` - Отображает элементы на странице.
- `onProductClick(productId: string): void` - Обрабатывает клик на продукт, вызывая функцию открытия превью.

#### Header
**Назначение:** Управляет отображением шапки сайта.
**Свойства:**
- `logo: HTMLImageElement` - Логотип.
- `basketButton: HTMLButtonElement` - Кнопка корзины.
- `basketCounter: HTMLSpanElement` - Счетчик товаров в корзине.
**Методы:**
- `updateBasketCounter(count: number): void` - Обновляет счетчик товаров в корзине, используя данные из корзины.

#### Modal
**Назначение:** Базовый класс для отображения модальных окон.
**Методы:**
- `open(content: HTMLElement): void` - Открывает модальное окно с переданным содержимым.
- `close(): void` - Закрывает модальное окно и очищает содержимое.
- `setState(isBlocked: boolean): void` - Управляет состоянием модального окна. Если `isBlocked` равно `true`, добавляется блокирующий стиль.

#### OrderStatusModal
**Назначение:** Управляет отображением статуса заказа в модальном окне.
**Методы:**
- `renderSuccess(orderId: string, totalAmount: number): HTMLElement` - Отображает успешный статус заказа.
- `renderFailure(errorMessage: string): HTMLElement` - Отображает сообщение об ошибке выполнения заказа.

#### Card
**Назначение:** Отвечает за отображение карточки товара на странице каталога.
**Методы:**
- `setText(element: HTMLElement, text: string): void` - Заменяет текстовое содержимое переданного элемента.
- `cardCategory(categoryName: string): void` - Устанавливает CSS класс для карточки товара, соответствующий категории.
- `setPrice(price: number): void` - Устанавливает цену товара в соответствующий элемент.

#### CardPreview (наследует Card)
**Назначение:** Отображает подробную информацию о товаре при его выборе, а также управляет кнопкой добавления в корзину.
**Методы:**
- `notSale(productData: object, isBlocked: boolean): void` - Проверяет наличие цены у товара. Если цена отсутствует и `isBlocked` равно `true`, блокирует возможность покупки.

#### Contacts
**Назначение:** Управляет отображением окна для ввода контактных данных пользователя (телефон и email).

### Пользовательский сценарий: 
1. Начинаем с каталога товаров. 
2. Кликаем по карточке товара и открывается его подробное описание. 
3. Добавляем товар в корзину с помощью кнопки "Купить". 
4. Возвращаемся в каталог и можем повторить этот процесс несколько раз, добавляя товары в корзину. 
5. Все добавленные товары будут отображаться в корзине. 
6. Кликаем на корзину, чтобы перейти к списку добавленных товаров, где можно изменять количество и удалять товары. 
7. Нажимаем кнопку "Оформить" и переходим к форме для ввода персональных данных. 
8. Заполняем форму с выбором способа оплаты и адресом доставки, а также указываем почту и номер телефона. 
9. После нажатия кнопки "Оплатить" происходит процесс оформления заказа. 
10. На экране появляется уведомление о том, что заказ оформлен, и сумма списана (при успешной оплате). 
